// Copyright (c) 2014-2015 K Team. All Rights Reserved.
package org.kframework.backend.java.symbolic;

import org.kframework.backend.java.kil.*;
import org.kframework.backend.java.kil.CellCollection.Cell;
import org.kframework.backend.java.rewritemachine.MatchingInstruction;
import org.kframework.backend.java.rewritemachine.RHSInstruction;
import org.kframework.backend.java.util.Profiler;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.List;
import java.util.Map;


/**
 * K abstract rewrite machine. Given a subject term and a rewrite rule, the
 * rewrite machine attempts to apply the rewrite rule by executing the
 * instructions generated by the rewrite rule. When the rule matches the subject
 * term, the rewrite machine performs efficient destructive updates to the
 * subject term such that its previous state before rewriting is not preserved.
 *
 * @author YilongL
 *
 */
public class AbstractKMachine {

    private final ConstrainedTerm subject;
    private final List<MatchingInstruction> instructions;
    private final Map<CellLabel, Term> cells;

    // program counter
    private int pc = 1;
    private boolean success = true;
    private ConjunctiveFormula substitution;

    private final SymbolicUnifier unifier;

    private final TermContext context;

    private AbstractKMachine(
            ConstrainedTerm subject,
            List<MatchingInstruction> instructions,
            Map<CellLabel, Term> cells,
            TermContext context) {
        this.subject = subject;
        this.instructions = instructions;
        this.cells = cells;
        this.substitution = ConjunctiveFormula.of(context);
        this.unifier = new SymbolicUnifier(context);
        this.context = context;
    }

    public static ConjunctiveFormula unify(
            ConstrainedTerm subject,
            List<MatchingInstruction> instructions,
            Map<CellLabel, Term> cells,
            TermContext context) {
        return new AbstractKMachine(subject, instructions, cells, context).unify();
    }

    public static CellCollection apply(
            CellCollection subject,
            Substitution<Variable, Term> substitution,
            Rule rule,
            TermContext context) {
        return new RHSConstructor(substitution, rule, context).transform(subject);
    }

    private ConjunctiveFormula unify() {
        match(DataStructures.getCellEntry(subject.term()));
        if (success) {
            return substitution;
        } else {
            return null;
        }
    }

    private static class RHSConstructor extends CopyOnWriteTransformer {

        private final Substitution<Variable, Term> substitution;
        private final Rule rule;

        private RHSConstructor(Substitution<Variable, Term> substitution, Rule rule, TermContext context) {
            super(context);
            this.substitution = substitution;
            this.rule = rule;
        }

        @Override
        public CellCollection transform(CellCollection cellCollection) {
            assert cellCollection.isConcreteCollection();

            boolean changed = false;
            CellCollection.Builder builder = CellCollection.builder(context.definition());
            for (CellCollection.Cell cell : cellCollection.cells().values()) {
                CellCollection selectedCell = (CellCollection) substitution.get(Rule.getChoiceVariableForCell(cell.cellLabel()));
                if (selectedCell != null && !cell.equals(selectedCell.cells().values().iterator().next())) {
                    builder.put(cell.cellLabel(), cell.content());
                } else if (isWriteCell(cell.cellLabel())) {
                    List<RHSInstruction> instructions = getWriteCellInstructions(cell.cellLabel());
                    builder.put(cell.cellLabel(), construct(instructions, substitution, context));
                    changed = true;
                } else if (cell.content() instanceof CellCollection) {
                    CellCollection transformedContent = transform((CellCollection) cell.content());
                    builder.put(cell.cellLabel(), transformedContent);
                    changed = changed || cell.content() != transformedContent;
                } else {
                    builder.put(cell.cellLabel(), cell.content());
                }
            }
            return changed ? (CellCollection) builder.build() : cellCollection;
        }

        private boolean isWriteCell(CellLabel cellLabel) {
            return rule.rhsOfWriteCell().keySet().contains(cellLabel);
        }

        private List<RHSInstruction> getWriteCellInstructions(CellLabel cellLabel) {
            return rule.instructionsOfWriteCell().get(cellLabel);
        }
    }

    public static Term construct(
            List<RHSInstruction> rhsInstructions,
            Map<Variable, Term> substitution,
            TermContext context) {
        if (rhsInstructions.size() == 1) {
            RHSInstruction instruction = rhsInstructions.get(0);
            switch (instruction.type()) {
            case PUSH:
                return instruction.term();
            case SUBST:
                Variable variable = (Variable) instruction.term();
                Term content = substitution.get(variable);
                if (content == null) {
                    content = variable;
                }
                return content;
            default:
                assert false : "unreachable";
            }
        }

        Deque<Term> stack = new ArrayDeque<>();
        for (RHSInstruction instruction : rhsInstructions) {
            switch (instruction.type()) {
            case PUSH:
                stack.push(instruction.term());
                break;
            case CONSTRUCT:
                RHSInstruction.Constructor constructor = instruction.constructor();
                switch (constructor.type()) {
                case BUILTIN_LIST:
                    BuiltinList.Builder builder = BuiltinList.builder(context);
                    for (int i = 0; i < constructor.size1(); i++) {
                        builder.addItem(stack.pop());
                    }
                    for (int i = 0; i < constructor.size2(); i++) {
                        builder.concatenate(stack.pop());
                    }
                    for (int i = 0; i < constructor.size3(); i++) {
                        builder.addItem(stack.pop());
                    }
                    stack.push(builder.build());
                    break;
                case BUILTIN_MAP:
                    BuiltinMap.Builder builder1 = BuiltinMap.builder(context);
                    for (int i = 0; i < constructor.size1(); i++) {
                        Term key = stack.pop();
                        Term value = stack.pop();
                        builder1.put(key, value);
                    }
                    for (int i = 0; i < constructor.size2(); i++) {
                        builder1.concatenate(stack.pop());
                    }
                    stack.push(builder1.build());
                    break;
                case BUILTIN_SET:
                    BuiltinSet.Builder builder2 = BuiltinSet.builder(context);
                    for (int i = 0; i < constructor.size1(); i++) {
                        builder2.add(stack.pop());
                    }
                    for (int i = 0; i < constructor.size2(); i++) {
                        builder2.concatenate(stack.pop());
                    }
                    stack.push(builder2.build());
                    break;
                case KITEM:
                    Term kLabel = stack.pop();
                    Term kList = stack.pop();
                    stack.push(KItem.of(kLabel, kList, context, constructor.getSource(), constructor.getLocation()));
                    break;
                case KITEM_PROJECTION:
                    stack.push(new KItemProjection(constructor.kind(), stack.pop()));
                    break;
                case KLABEL_FREEZER:
                    stack.push(new KLabelFreezer(stack.pop()));
                    break;
                case KLABEL_INJECTION:
                    stack.push(new KLabelInjection(stack.pop()));
                    break;
                case INJECTED_KLABEL:
                    stack.push(new InjectedKLabel(stack.pop()));
                    break;
                case KLIST:
                    KList.Builder builder3 = KList.builder();
                    for (int i = 0; i < constructor.size1(); i++) {
                        builder3.concatenate(stack.pop());
                    }
                    stack.push(builder3.build());
                    break;
                case KSEQUENCE:
                    KSequence.Builder builder4 = KSequence.builder();
                    for (int i = 0; i < constructor.size1(); i++) {
                        builder4.concatenate(stack.pop());
                    }
                    stack.push(builder4.build());
                    break;
                case CELL_COLLECTION:
                    CellCollection.Builder builder5 = CellCollection.builder(context.definition());
                    for (CellLabel cellLabel : constructor.cellLabels()) {
                        builder5.add(new Cell(cellLabel, stack.pop()));
                    }
                    for (int i = 0; i < constructor.size1(); i++) {
                        builder5.concatenate(stack.pop());
                    }
                    stack.push(builder5.build());
                    break;
                default:
                    assert false : "unreachable";
                }
                break;
            case SUBST:
                Variable variable = (Variable) instruction.term();
                Term term = substitution.get(variable);
                if (term == null) {
                    term = variable;
                }
                stack.push(term);
                break;
            case EVAL:
                KItem kItem = (KItem) stack.pop();
                stack.push(kItem.resolveFunctionAndAnywhere(true, context));
                break;
            case PROJECT:
                KItemProjection projection = (KItemProjection) stack.pop();
                stack.push(projection.evaluateProjection());
                break;
            }
        }
        assert stack.size() == 1;
        return stack.pop();
    }

    private void match(CellCollection.Cell cell) {
        if (isReadCell(cell.cellLabel())) {
            // perform matching under read cell
            Profiler.startTimer(Profiler.PATTERN_MATCH_TIMER);
            if (unifier.symbolicUnify(cell.content(), getReadCellLHS(cell.cellLabel()), substitution)) {
                substitution = unifier.constraint();
            } else {
                success = false;
            }
            Profiler.stopTimer(Profiler.PATTERN_MATCH_TIMER);

            if (!success) {
                return;
            }
        }

        while (true) {
            MatchingInstruction instruction = nextInstruction();
            if (instruction == MatchingInstruction.UP) {
                return;
            }

            if (instruction == MatchingInstruction.CHOICE) {
                assert cell.content() instanceof CellCollection && ((CellCollection) cell.content()).isConcreteCollection();
                instruction = nextInstruction();

                int successPC = -1; // pgm counter on success
                PersistentUniqueList<ConjunctiveFormula> substitutions = PersistentUniqueList.empty();
                for (CellCollection.Cell subCell : getSubCellsByLabel(cell, instruction.cellLabel())) {
                    int stashedPC = pc; // pgm counter before AC-matching
                    ConjunctiveFormula stashedSubstitution = substitution;
                    success = true;
                    match(subCell);
                    if (success) {
                        substitution = substitution.add(
                                Rule.getChoiceVariableForCell(instruction.cellLabel()),
                                CellCollection.singleton(
                                        subCell.cellLabel(),
                                        subCell.content(),
                                        context.definition()));
                        substitutions = substitutions.plus(substitution);
                        assert successPC == -1 || successPC == pc;
                        successPC = pc;
                    }
                    pc = stashedPC;
                    substitution = stashedSubstitution;
                }

                if (!substitutions.isEmpty()) {
                    if (substitutions.size() == 1) {
                        substitution = substitution.addAndSimplify(substitutions.get(0));
                        if (substitution.isFalse()) {
                            success = false;
                            return;
                        }
                    } else {
                        substitution = substitution.add(new DisjunctiveFormula(
                                substitutions,
                                context));
                    }
                    success = true;
                    pc = successPC;
                } else {
                    success = false;
                    return;
                }
            } else {
                assert instruction.type() == MatchingInstruction.Type.GOTO;
                List<CellCollection.Cell> cells = getSubCellsByLabel(cell, instruction.cellLabel());
                if (cells.size() != 1) {
                    success = false;
                    return;
                }
                match(cells.get(0));
                if (!success) {
                    return;
                }
            }
        }
    }

    private MatchingInstruction nextInstruction() {
        return instructions.get(pc++);
    }

    private boolean isReadCell(CellLabel cellLabel) {
        return cells.keySet().contains(cellLabel);
    }

    private Term getReadCellLHS(CellLabel cellLabel) {
        return cells.get(cellLabel);
    }

    private static List<Cell> getSubCellsByLabel(CellCollection.Cell cell, CellLabel label) {
        assert cell.content() instanceof CellCollection : "expected contents of cell " + cell.cellLabel() + " to be a CellCollection but found " + cell.content().getClass().getSimpleName();
        return ((CellCollection) cell.content()).cells().get(label);
    }

}
